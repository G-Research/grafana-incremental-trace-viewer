//go:build go1.22

// Package plugin provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package plugin

import (
	"fmt"
	"net/http"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for SpanKind.
const (
	Client      SpanKind = "client"
	Consumer    SpanKind = "consumer"
	Internal    SpanKind = "internal"
	Producer    SpanKind = "producer"
	Server      SpanKind = "server"
	Unspecified SpanKind = "unspecified"
)

// Defines values for StatusCode.
const (
	Error StatusCode = "error"
	Ok    StatusCode = "ok"
	Unset StatusCode = "unset"
)

// Defines values for ValueOneofCase.
const (
	ValueOneofCaseArrayValue  ValueOneofCase = "arrayValue"
	ValueOneofCaseBoolValue   ValueOneofCase = "boolValue"
	ValueOneofCaseBytesValue  ValueOneofCase = "bytesValue"
	ValueOneofCaseDoubleValue ValueOneofCase = "doubleValue"
	ValueOneofCaseIntValue    ValueOneofCase = "intValue"
	ValueOneofCaseKvlistValue ValueOneofCase = "kvlistValue"
	ValueOneofCaseNone        ValueOneofCase = "none"
	ValueOneofCaseStringValue ValueOneofCase = "stringValue"
)

// AnyValue defines model for AnyValue.
type AnyValue struct {
	ArrayValue  *ArrayValue     `json:"arrayValue,omitempty"`
	BoolValue   *bool           `json:"boolValue,omitempty"`
	BytesValue  *[]int32        `json:"bytesValue"`
	DoubleValue *float64        `json:"doubleValue,omitempty"`
	IntValue    *int64          `json:"intValue,omitempty"`
	KvlistValue *KeyValueList   `json:"kvlistValue,omitempty"`
	StringValue *string         `json:"stringValue"`
	ValueCase   *ValueOneofCase `json:"valueCase,omitempty"`
}

// ArrayValue defines model for ArrayValue.
type ArrayValue struct {
	Values *[]AnyValue `json:"values"`
}

// DataSourceInfo Information about the datasource to use for the search.
// This has the OpenSearch specific fields to connect to the datasource.
// It will later have the exactly Tempo API information.
type DataSourceInfo struct {
	Database  string  `json:"database"`
	TimeField *string `json:"timeField,omitempty"`
	Type      string  `json:"type"`
	URL       string  `json:"url"`
}

// EntityRef defines model for EntityRef.
type EntityRef struct {
	DescriptionKeys *[]string `json:"descriptionKeys"`
	IDKeys          *[]string `json:"idKeys"`
	SchemaURL       *string   `json:"schemaUrl"`
	Type            *string   `json:"type"`
}

// Event defines model for Event.
type Event struct {
	Attributes             *[]KeyValue `json:"attributes"`
	DroppedAttributesCount *int32      `json:"droppedAttributesCount,omitempty"`
	Name                   *string     `json:"name"`
	TimeUnixNano           *int64      `json:"timeUnixNano,omitempty"`
}

// InstrumentationScope defines model for InstrumentationScope.
type InstrumentationScope struct {
	Attributes             *[]KeyValue `json:"attributes"`
	DroppedAttributesCount *int32      `json:"droppedAttributesCount,omitempty"`
	Name                   *string     `json:"name"`
	Version                *string     `json:"version"`
}

// KeyValue defines model for KeyValue.
type KeyValue struct {
	Key   *string   `json:"key"`
	Value *AnyValue `json:"value,omitempty"`
}

// KeyValueList defines model for KeyValueList.
type KeyValueList struct {
	Values *[]KeyValue `json:"values"`
}

// Link defines model for Link.
type Link struct {
	Attributes             *[]KeyValue `json:"attributes"`
	DroppedAttributesCount *int32      `json:"droppedAttributesCount,omitempty"`
	Flags                  *int32      `json:"flags,omitempty"`
	SpanID                 *[]int32    `json:"spanId"`
	TraceID                *[]int32    `json:"traceId"`
	TraceState             *string     `json:"traceState"`
}

// Resource defines model for Resource.
type Resource struct {
	Attributes             *[]KeyValue  `json:"attributes"`
	DroppedAttributesCount *int32       `json:"droppedAttributesCount,omitempty"`
	EntityRefs             *[]EntityRef `json:"entityRefs"`
}

// ResourceSpans defines model for ResourceSpans.
type ResourceSpans struct {
	Resource   *Resource     `json:"resource,omitempty"`
	SchemaURL  *string       `json:"schemaUrl"`
	ScopeSpans *[]ScopeSpans `json:"scopeSpans"`
}

// ScopeSpans defines model for ScopeSpans.
type ScopeSpans struct {
	SchemaURL *string               `json:"schemaUrl"`
	Scope     *InstrumentationScope `json:"scope,omitempty"`
	Spans     *[]Span               `json:"spans"`
}

// Span defines model for Span.
type Span struct {
	Attributes             *[]KeyValue `json:"attributes"`
	DroppedAttributesCount *int32      `json:"droppedAttributesCount,omitempty"`
	DroppedEventsCount     *int32      `json:"droppedEventsCount,omitempty"`
	DroppedLinksCount      *int32      `json:"droppedLinksCount,omitempty"`
	EndTimeUnixNano        *int64      `json:"endTimeUnixNano,omitempty"`
	Events                 *[]Event    `json:"events"`
	Flags                  *int32      `json:"flags,omitempty"`
	Kind                   *SpanKind   `json:"kind,omitempty"`
	Links                  *[]Link     `json:"links"`
	Name                   *string     `json:"name"`
	ParentSpanID           *[]int32    `json:"parentSpanId"`
	SpanID                 *[]int32    `json:"spanID"`
	StartTimeUnixNano      *int64      `json:"startTimeUnixNano,omitempty"`
	Status                 *Status     `json:"status,omitempty"`
	TraceID                *[]int32    `json:"traceId"`
	TraceState             *string     `json:"traceState"`
}

// SpanKind defines model for SpanKind.
type SpanKind string

// SpanSet defines model for SpanSet.
type SpanSet struct {
	Matched *int32  `json:"matched,omitempty"`
	Spans   *[]Span `json:"spans"`
}

// Status defines model for Status.
type Status struct {
	Code    *StatusCode `json:"code,omitempty"`
	Message *string     `json:"message"`
}

// StatusCode defines model for StatusCode.
type StatusCode string

// TempoMetrics defines model for TempoMetrics.
type TempoMetrics struct {
	InspectedBytes  *int32 `json:"inspectedBytes"`
	InspectedTraces *int32 `json:"inspectedTraces"`
	TotalBlocks     *int32 `json:"totalBlocks"`
}

// TempoTrace defines model for TempoTrace.
type TempoTrace struct {
	Duration        *string    `json:"duration,omitempty"`
	RootServiceName *string    `json:"rootServiceName"`
	RootTraceName   *string    `json:"rootTraceName"`
	SpanSets        *[]SpanSet `json:"spanSets"`
	StartTime       *time.Time `json:"startTime,omitempty"`
	TraceID         *string    `json:"traceID"`
}

// TempoV1Response defines model for TempoV1Response.
type TempoV1Response struct {
	Metrics   *TempoMetrics `json:"metrics,omitempty"`
	TagNames  *[]string     `json:"tagNames"`
	TagValues *[]string     `json:"tagValues"`
	Traces    *[]TempoTrace `json:"traces"`
}

// TracesData defines model for TracesData.
type TracesData struct {
	ResourceSpans *[]ResourceSpans `json:"resourceSpans"`
}

// ValueOneofCase defines model for ValueOneofCase.
type ValueOneofCase string

// SearchParams defines parameters for Search.
type SearchParams struct {
	Q     string `form:"q" json:"q"`
	Start int    `form:"start" json:"start"`
	End   int    `form:"end" json:"end"`
	Spss  *int32 `form:"spss,omitempty" json:"spss,omitempty"`
}

// QueryTraceParams defines parameters for QueryTrace.
type QueryTraceParams struct {
	Start *int `form:"start,omitempty" json:"start,omitempty"`
	End   *int `form:"end,omitempty" json:"end,omitempty"`

	// Depth The depth of the query.
	// If not provided, the default depth will be used.
	Depth *int `form:"depth,omitempty" json:"depth,omitempty"`

	// ChildrenLimit The maximum number of children to fetch on each level.
	ChildrenLimit *int `form:"childrenLimit,omitempty" json:"childrenLimit,omitempty"`

	// SpanID The parent span id to start the query from.
	// If not provided, the root span will be used.
	SpanID *string `form:"spanId,omitempty" json:"spanId,omitempty"`

	// Skip The number of spans to skip.
	// Should only be used in combination with spanId.
	Skip *int `form:"skip,omitempty" json:"skip,omitempty"`

	// Take The number of spans to take.
	// Should only be used in combination with spanId.
	Take *int `form:"take,omitempty" json:"take,omitempty"`
}

// SearchJSONRequestBody defines body for Search for application/json ContentType.
type SearchJSONRequestBody = DataSourceInfo

// QueryTraceJSONRequestBody defines body for QueryTrace for application/json ContentType.
type QueryTraceJSONRequestBody = DataSourceInfo

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Search for traces
	// (POST /api/search)
	Search(w http.ResponseWriter, r *http.Request, params SearchParams)
	// Get a trace details by id
	// (POST /api/v2/traces/{traceId})
	QueryTrace(w http.ResponseWriter, r *http.Request, traceID string, params QueryTraceParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// Search operation middleware
func (siw *ServerInterfaceWrapper) Search(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchParams

	// ------------- Required query parameter "q" -------------

	if paramValue := r.URL.Query().Get("q"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "q"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "q", r.URL.Query(), &params.Q)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "q", Err: err})
		return
	}

	// ------------- Required query parameter "start" -------------

	if paramValue := r.URL.Query().Get("start"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "start"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "start", r.URL.Query(), &params.Start)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "start", Err: err})
		return
	}

	// ------------- Required query parameter "end" -------------

	if paramValue := r.URL.Query().Get("end"); paramValue != "" {

	} else {
		siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "end"})
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "end", r.URL.Query(), &params.End)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "end", Err: err})
		return
	}

	// ------------- Optional query parameter "spss" -------------

	err = runtime.BindQueryParameter("form", true, false, "spss", r.URL.Query(), &params.Spss)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "spss", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.Search(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// QueryTrace operation middleware
func (siw *ServerInterfaceWrapper) QueryTrace(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "traceId" -------------
	var traceID string

	err = runtime.BindStyledParameterWithOptions("simple", "traceId", r.PathValue("traceId"), &traceID, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "traceId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params QueryTraceParams

	// ------------- Optional query parameter "start" -------------

	err = runtime.BindQueryParameter("form", true, false, "start", r.URL.Query(), &params.Start)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "start", Err: err})
		return
	}

	// ------------- Optional query parameter "end" -------------

	err = runtime.BindQueryParameter("form", true, false, "end", r.URL.Query(), &params.End)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "end", Err: err})
		return
	}

	// ------------- Optional query parameter "depth" -------------

	err = runtime.BindQueryParameter("form", true, false, "depth", r.URL.Query(), &params.Depth)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "depth", Err: err})
		return
	}

	// ------------- Optional query parameter "childrenLimit" -------------

	err = runtime.BindQueryParameter("form", true, false, "childrenLimit", r.URL.Query(), &params.ChildrenLimit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "childrenLimit", Err: err})
		return
	}

	// ------------- Optional query parameter "spanId" -------------

	err = runtime.BindQueryParameter("form", true, false, "spanId", r.URL.Query(), &params.SpanID)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "spanId", Err: err})
		return
	}

	// ------------- Optional query parameter "skip" -------------

	err = runtime.BindQueryParameter("form", true, false, "skip", r.URL.Query(), &params.Skip)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skip", Err: err})
		return
	}

	// ------------- Optional query parameter "take" -------------

	err = runtime.BindQueryParameter("form", true, false, "take", r.URL.Query(), &params.Take)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "take", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.QueryTrace(w, r, traceID, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("POST "+options.BaseURL+"/api/search", wrapper.Search)
	m.HandleFunc("POST "+options.BaseURL+"/api/v2/traces/{traceId}", wrapper.QueryTrace)

	return m
}
